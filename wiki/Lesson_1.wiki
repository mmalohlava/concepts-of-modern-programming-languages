#summary Groovy introduction, collections, functional programming, meta-programming, DSLs.
#labels Featured,Phase-Requirements
#sidebar TOC

= Lesson 1 details =

== Agenda ==

  * Language dynamism - typing, casting, object construction, method invocation
  * Functional programming in OO languages
  * Scripting
  * Dynamic meta-programming
  * Intro into Domain Specific Languages

== Preparation ==

  * Grab Groovy from [http://groovy.codehaus.org/Download the groovy download page]
  * Install Java (if you don't have it installed) from [http://www.oracle.com/technetwork/java/javase/downloads/index.html the Java download site]

== Resources ==

Grab the [http://code.google.com/p/concepts-of-modern-programming-languages/downloads/detail?name=lecture1.zip&can=2&q= lecture1.zip] file to get the slides and code examples to work with during the lesson.

== Homework ==

{{{
import java.util.concurrent.locks.ReentrantLock

//In concurrent programms it is very important to protect access to shared mutable data. Locks is one way to prevent race conditions on share data,
//however, the expected try-catch-finally structure is a somewhat verbose and error-prone.
ReentrantLock lock = new ReentrantLock()

int sum = 0

threads = (0..50).collect {num ->
    Thread.start {
        lock.lock()
        try {
            println 'Holding the lock'
            sum += num
        } finally {
            lock.unlock()
        }
        println 'Not holding the lock'
    }
}
threads*.join()
assert 1275 == sum

//TASK Define a withLock method on the ReentrantLock class that would protect shared data from concurrent access
}}}
//when evaluating the supplied piece of code and that would safely unlock the data once the block of code finishes.


sum = 0

threads = (0..50).collect {num ->
    Thread.start {
        lock.withLock {
            println 'Holding the lock'
            sum += num
        }
        println 'Not holding the lock'
    }
}
threads*.join()
assert 1275 == sum

println 'done'
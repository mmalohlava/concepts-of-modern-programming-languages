#summary Introduction to Erlang
#sidebar TOC

= Lesson 5 details =

== Agenda ==

  * Erlang introduction
  * Erlang distribution and robustness
    * cluster creation
    * message passing
    * RPC calls
  * Erlang support for concurrency
    * `plists` library

== Erlang Lecture notes ==
  * Erlang is a functional language
  * Erlang created 1986 in Ericsson
    * implementation of AXD301 switch

  * variable names starts with upper letter (e.g., `Number = 3`), variables are immutable 
    * `f().` 

  
  * cluster creation
    * start Erlang shell with given node's name and share the same cookine name
    {{{
erl -name malohlava@10.10.16.105 -setcookie erlang_workshop
    }}}
    * append current node to the cluster where node `martin@10.10.16.109` is located
    {{{
net_adm:ping('martin@10.10.16.109').
    }}}
    * name of the current node: `node().`
    * list of all nodes in the cluster: `nodes().`

 * compile the module `fact` from the shell
 {{{
> c(fact)
{ok,fact}
> fact:fact(4)
24
 }}}

 * Erlang types
   * `$a` represents number of 'a' character
   * `2#101` stands for 6 (`2` is a base, `101` is a 2-based number) 
   * `my_shell` is an atom. Atom starts with small letter.
     * `true`, `false` are atoms
   * references - `make_ref()` - returns unique identification 
   * functions (first-class entities)
     * `fun(N) -> fact:fac(N) end.
   * Pid - identification of Erlang process. For example: `MyPid = spawn(fact, fac, [1000])`
        * `fact` - module name
        * `fac` - function provided by module `fact`
        * `[1000]` - parameter list for function `fac`
   * `Self()` returns identification of current process
   * Tuples `{adam, 24, {july, 21}}`
   * Lists `[1,2, "a"]`
     * [100, 100, 100] is also interpred as the string "ddd"

   * Erlang types are ordered.
     * E.g., `-1 < make_ref()` is true

   * equality
     * value-based via `==`
     * identity-based via `=:=`

   * operators `and`,`or` evaluate whole expression
   * operators `orelse`, `andelse` support partial evaluation of expressions (like in C or Java)

 * Shell
   * Associate a name with current shell (i.e., process) via `register(my_shell, self()).`

 * Messages
   * send a message to a process on a given node. Process have to be named!
     {{{
{ my_shell, "michal@10.10.1.16"} ! 'This is a message'.
}}}
   * receive a message
{{{
flush() -> 
    receive 
      Msg -> io:format("You have a message: ~p~n", [Msg]),
                       flush()
    after 0 -> ok
end.
     }}}

 * RPC calls
  * `rpc:call(node, io, format, ['Hello']).`
  * `rpc:multicall(io, format, ['Hello']).`

 * Plists library (see http://code.google.com/p/plists/) for parallel computation
   * Current node, 3 processes compute Fibionacioho numbers in given range `plists:map( fun(N) -> mff:fib(N) rem 1000 end, lists:seq(30000, 30010), [1, {processes, 3}]).`
   * All nodes (1 process on each node spawn) compute Fibionacioho numbers in given range
{{{
Nodes = nodes().
plists:map( fun(N) -> mff:fib(N) rem 1000 end, lists:seq(300000, 30010), [1, {nodes, Nodes}]).
   }}}

 * Monitor processes
   * start GUI process monitor via `appmon:start().` or via toolbar GUI `toolbar:start().`

== Preparation ==
 * Checkout the recent state of our project from [http://code.google.com/p/concepts-of-modern-programming-languages/source/checkout SVN]
 * Install Java (if you don't have it installed) from [http://www.oracle.com/technetwork/java/javase/downloads/index.html the Java download site]
 * Install Erlang from http://www.erlang.org/download.html
   * Windows - download binary installation
   * Linux - download sources and compile them
 * For code editing, you can use Eclipse IDE
   * Install _Eclipse_ from http://www.eclipse.org/downloads/ - choose version called *Eclipse IDE for Java Developers* 
   * Open _Help -> Install new software..._ and put `http://erlide.org/update_nightly` into _Work with_ box.   
   * Install _Erlang IDE_
   * Restart Eclipse
   * Check installation - the list of perspectives should contain the perspective _Erlang_
 * Or alternatively you can use IDE SciTE
   * You can use also simple SciTE IDE 
     * Download it from from http://www.scintilla.org/SciTEDownload.html
     * Edit `SciTEGlobal.properties` and enable Erlang by uncommenting the line with `Erlang|erl||\`
 * Other alternative IDEs
    * See http://www.erlang.org/faq/tools.html#id53616

== Homework ==

The assignment is to implement a parallel merge sort on lists reflecting a given limit of concurrent processes.
Your implementation should follow [http://en.wikipedia.org/wiki/Merge_sort the classical merge sort algorithm] but for each sub-list it should release a new process sorting the sub-list.
However, the algorithm can release only the given limit of processes. If the algorithm consumes all available processes then it should use sequential processing.

  * _Note #1: It is possible to use plists library. See http://code.google.com/p/plists/ _
  * _Note #2: Advanced solutions can try to incorporate reuse of processes ;-). _

{{{
-module(sort).

%%
%% Exported Functions
%%
-export([test_pmerge_sort/0, pmerge_sort/2]).

%%
%% API Functions
%%

test_pmerge_sort() ->
	% max number of processes
	MaxPids = 10,
	% a list to be sorted
	L = [random:uniform(1000000) || _ <- lists:seq(1, 1000000)],	
	timer:tc(sort, pmerge_sort, [L, MaxPids]).

pmerge_sort(List, MaxProcesses) -> % YOUR ASSIGNMENT.
    
}}}

The source code is located in [http://concepts-of-modern-programming-languages.googlecode.com/svn/trunk/2011-12/lesson5/homework/sort.erl SVN repository].


== Recommended reading ==
  * Open source Erlang - http://erlang.org/
  * Commercial Erlang - http://erlang.se/
  * http://learnyousomeerlang.com/
  * Erlang programming rules - http://www.erlang.se/doc/programming_rules.shtml#HDR19
  * Erlang documentation - http://erldocs.com/
  * Erlang wiki - http://www.trapexit.org/
    * Erlang cookbook - http://www.trapexit.org/Category:CookBook
  * Erlang utilities - http://jungerl.sourceforge.net/
  * Erlang examples - http://ftp.sunet.se/pub/lang/erlang/examples/examples-2.0.html
  * Joe Armstrong, [http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.116.1969&rep=rep1&type=pdf Concurrency Oriented Programming in Erlang]
  * Martin Logan, Eric Merritt, and Richard Carlsson: [http://www.manning.com/logan/ Erlang and OTP in Action]

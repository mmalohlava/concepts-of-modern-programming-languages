#summary High-level concurrency principles in modern languages
#labels Featured
#sidebar TOC

= Lesson 5 details =

== Agenda ==

  * Dataflow
  * Actors
  * Parallel collections
  * Agents
  * Fork/Join

== Preparation ==

  * Grab Groovy 2.3 from [http://groovy.codehaus.org/Download the groovy download page]
  * Install Java JDK (if you don't have it installed) from [http://www.oracle.com/technetwork/java/javase/downloads/index.html the Java download site]

== Resources ==

Grab the [http://code.google.com/p/concepts-of-modern-programming-languages/downloads/detail?name=lecture6.zip&can=2&q= lecture6.zip] file to get the slides and code examples to work with during the lesson.


== Homework ==

{{{
import groovyx.gpars.dataflow.DataflowQueue
import groovyx.gpars.group.DefaultPGroup

//Three channels deliver daily prices of a particular stock traded at three locations - Paris, Vienna and Chicago.
//The prices are in EUR for Paris and Vienna and in USD for Chicago.
//A fourth channels delivers daily exchange rates for EUR to USD conversion (price of one USD in EUR).
//The operator-based calculation uses several intermediate channels and three operators to:
//  1. convert USD prices to EUR
//  2. calculate daily average prices in EUR of the stock across all three markets
//  3. calculate a five-day moving average of the price calculated in 2.
//The output of 2. and 3. each comes from a separate channel (avgPrices and fiveDayAverages, respectively).
//The two channels are consumed by tasks that print the values on the screen.

//TASK Implement the three missing operators, possibly connected with additional channels, so that the calculation passes.
//The first operator will convert Chicago prices from USD to EUR
//The second operator will calculate a daily average price in EUR using the three daily prices from different locations as its input
//The third operator will take the daily average prices calculated by the second operator and output a five-day moving average (an average of the last five days, including today).
//If the history is shorter than five days, use only the days that are available to calculate the average.
//
//Hint for GPars operators syntax:
/*
    operator(inputs: [...], outputs: [...], stateObject: [key: value]) { a, b, c, d ->  //values from all input channels
        assert stateObject.key == value //access the state object through the key
        stateObject.key = newValue
    
        bindOutput("something")  //output to the only output channel, if there's only one
        bindOutput(0, "something")  //output to the first output channel
        bindAllOutputs("something")  //output to all output channels
    }

*/

//Dummy price and exchange rate data
final prices1 = [10, 11, 12, 10, 9, 8, 7, 9, 6, 7,
                 10, 9, 12, 12, 14, 14, 12, 13, 12, 14,
                 10, 11, 10, 12, 14, 15, 12, 13, 14, 12]
final prices2 = [10, 11, 12, 10, 9, 8, 7, 9, 6, 7,
                 10, 9, 12, 12, 14, 14, 12, 13, 12, 14,
                 10, 11, 10, 12, 14, 15, 12, 13, 14, 12]
final prices3 = [12, 12, 12, 12, 12, 9, 8, 9, 7, 9,
                 11, 11, 13, 11, 14, 15, 13, 14, 12, 14,
                 11, 12, 11, 11, 13, 15, 13, 14, 15, 13]
final rates = [0.81, 0.82, 0.82, 0.81, 0.81, 0.81, 0.82, 0.81, 0.81, 0.82,
               0.79, 0.81, 0.85, 0.88, 0.81, 0.81, 0.83, 0.83, 0.84, 0.81,
               0.81, 0.80, 0.83, 0.81, 0.85, 0.89, 0.93, 0.87, 0.82, 0.81]

//a thread pool to use
final group = new DefaultPGroup()

group.with {
    //input channels
    final parisEURPrices = new DataflowQueue()
    final viennaEURPrices = new DataflowQueue()
    final chicagoUSDPrices = new DataflowQueue()
    final usd2eurRates = new DataflowQueue()

    //output channels
    final avgPrices = new DataflowQueue()
    final fiveDayAverages = new DataflowQueue()

    //================================= do not modify above this point
    
    //implement the three operators and utility intermediate channels here
















    //================================= do not modify beyond this point
    

    //Generate the input data streams from the dummy data
    task {
        prices1.each { parisEURPrices << it }
    }
    task {
        prices2.each { viennaEURPrices << it }
    }
    task {
        prices3.each { chicagoUSDPrices << it }
    }
    task {
        rates.each { usd2eurRates << it }
    }

    //Retrieve the results
    def results = task {
        def result = []
        30.times {
            result << (int) avgPrices.val
        }
        [dailyAveragesKey: result]
    }.then { results ->
        def result = []
        30.times {
            result << (int) fiveDayAverages.val
        }
        results["fiveDayAveragesKey"] = result
        results
    }.get()

    //Print the results
    println "Daily averages:    \t${results['dailyAveragesKey'].join(',\t')}"
    println "Five day averages: \t${results['fiveDayAveragesKey'].join(',\t')}"

    assert results['dailyAveragesKey'] == [9, 10, 11, 9, 9, 7, 6, 8, 5, 7, 9, 8, 11, 11, 13, 13, 11, 12, 11, 13, 9, 10, 9, 10, 13, 14, 12, 12, 13, 11]
    assert results['fiveDayAveragesKey'] == [9, 10, 10, 10, 10, 9, 9, 8, 7, 7, 7, 7, 8, 9, 10, 11, 12, 12, 12, 12, 11, 11, 10, 10, 10, 11, 12, 12, 13, 12]
}

group.shutdown()
println 'done'
}}}